<!DOCTYPE html>
<html>
    <head>
        <title>Mathal Combat!</title>
        <link rel="icon" href="./resources/favicon.png" type="image/png">
        <style>
            body {
                font-family: Arial, sans-serif;
                margin: 20px;
                padding-top: 60px; /* to avoid overlap with fixed header */
                background-color: #222222;
                color: white;
                width: 100%-10px;
            }
            
            .header {
                background-color: #333333;
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                padding: 10px;
                font-size: 24px;
                font-weight: bold;
                margin-bottom: 20px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                z-index: 1000;
            }

            .goback {
                background-color: #222222;
                top: 0;
                color:white;
                left: 0;
                padding: 10px;
                font-size: 24px;
                font-weight: bold;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                z-index: 1000;
                border: none;
                border-radius: 10px;
                cursor: pointer;
            }
            
            canvas {
                background-color: #111111;
                display: block;
            }

            input {
                margin: 5px;
                background-color:#000000;
                padding: 5px;
                border-radius: 3px;
                border:0;
                color: white;

            }

            .launch {
                border-radius: 5px;
                border:none;
                background-image: linear-gradient(blue, green);
                color: white;
                padding: 10px 20px;
                font-size: 16px;
                cursor: pointer;
            }

            .launch:active {
                background-image: linear-gradient(darkblue, darkgreen);
            }

        </style>
    </head>
    <body onload="resizeCanvas()" id="body">
        <div class="header" id="header"><button class="goback" title="Go Back to All Simulations" onclick="javascript:window.location.href='../'">Physics Simulations</button></div>
        <div id="menu"></div>

        <h1>Mathal Combat!</h1>
        Fight and do math!<br>

        <canvas id="simulationCanvas" width="800" height="600" style="border:1px solid #000000;">
            Your browser does not support the HTML5 canvas tag.
        </canvas><br>

        <script>
            function resizeCanvas() {
                const canvas = document.getElementById('simulationCanvas');
                canvas.width = document.getElementById("body").offsetWidth;
            }

            // Basic sprite-based melee demo with two attack types (punch, swing).
            // Animation frames are loaded from the resources folder.
            const canvas = document.getElementById('simulationCanvas');
            const ctx = canvas.getContext('2d');

            function ensureCanvasSize() {
                // preserve behavior from existing resizeCanvas; also set height reasonably
                canvas.width = document.getElementById("body").offsetWidth;
                canvas.height = Math.max(320, window.innerHeight - 160);
            }
            ensureCanvasSize();
            window.addEventListener('resize', ensureCanvasSize);

            // Load animation frames from resources folder.
            // Use resources/player0_punch0.png as the idle sprite (punchFrames[0]).
            const punchFrames = [];
            const swingFrames = [];
            const PUNCH_COUNT = 5;
            const SWING_COUNT = 5;

            for (let i = 0; i < PUNCH_COUNT; i++) {
                const img = new Image();
                img.src = `resources/player0_punch${i}.png`;
                punchFrames.push(img);
            }

            for (let i = 0; i < SWING_COUNT; i++) {
                const img = new Image();
                img.src = `resources/player0_swing${i}.png`;
                swingFrames.push(img);
            }

            // New: load a base body sprite and a sword sprite. We'll draw the sword over the base sprite during a swing.
            const baseSprite = new Image();
            baseSprite.src = `resources/player0_0.png`;
            const swordImg = new Image();
            swordImg.src = `resources/sword.png`;

            const KEYS = {};
            window.addEventListener('keydown', (e) => { KEYS[e.key.toLowerCase()] = true; });
            window.addEventListener('keyup', (e) => { KEYS[e.key.toLowerCase()] = false; });

            // Platform definitions
            let platforms = [
                { x: 0, y: canvas.height - 10, w: canvas.width, h: 10 }, // floor
                { x: canvas.width * 0.15, y: canvas.height - 150, w: canvas.width * 0.3, h: 12 }, // left platform
                { x: canvas.width * 0.5, y: canvas.height - 250, w: canvas.width * 0.25, h: 12 }, // middle platform
                { x: canvas.width * 0.65, y: canvas.height - 180, w: canvas.width * 0.3, h: 12 } // right platform
            ];

            // Make sure platforms update when canvas resizes
            window.addEventListener('resize', () => {
                platforms = [
                    { x: 0, y: canvas.height - 10, w: canvas.width, h: 10 },
                    { x: canvas.width * 0.15, y: canvas.height - 150, w: canvas.width * 0.3, h: 12 },
                    { x: canvas.width * 0.5, y: canvas.height - 250, w: canvas.width * 0.25, h: 12 },
                    { x: canvas.width * 0.65, y: canvas.height - 180, w: canvas.width * 0.3, h: 12 }
                ];
            });

            // Utility
            function rectIntersect(a, b) {
                return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h);
            }

            // ---------- Math-challenge logic ----------
            // When player's stamina is below 10, require solving a precalc-level problem before allowing stamina-consuming actions.
            let challengeActive = false;
            let challengeCallback = null;

            function generatePrecalcProblem() {
                // return {question, answer} where answer is numeric
                const type = Math.floor(Math.random() * 5); // 0..4
                if (type === 0) {
                    // linear: ax + b = c  -> x = (c - b)/a
                    const a = Math.floor(Math.random() * 9) + 1;
                    const x = Math.floor(Math.random() * 11) - 5;
                    const b = Math.floor(Math.random() * 21) - 10;
                    const c = a * x + b;
                    return { question: `Solve for x: ${a}x + ${b} = ${c}`, answer: x };
                } else if (type === 1) {
                    // exponential: base^x = N
                    const base = 2 + Math.floor(Math.random() * 4); // 2..5
                    const x = Math.floor(Math.random() * 5) + 1; // 1..5
                    const n = Math.pow(base, x);
                    return { question: `Solve for x: ${base}^x = ${n}`, answer: x };
                } else if (type === 2) {
                    // logarithm: log_b(N) = x
                    const base = 2 + Math.floor(Math.random() * 4);
                    const x = Math.floor(Math.random() * 5) + 1;
                    const n = Math.pow(base, x);
                    return { question: `Solve for x: log base ${base} of ${n} = x`, answer: x };
                } else if (type === 3) {
                    // quadratic: ask sum or product of roots for x^2 + bx + c = 0 (integer roots)
                    const r1 = Math.floor(Math.random() * 11) - 5;
                    let r2 = Math.floor(Math.random() * 11) - 5;
                    // ensure not both zero for interest
                    if (r1 === 0 && r2 === 0) r2 = 1;
                    const b = -(r1 + r2);
                    const c = r1 * r2;
                    if (Math.random() < 0.5) {
                        // ask sum
                        return { question: `Given x^2 ${b >= 0 ? '+' + b : b}x ${c >= 0 ? '+' + c : c} = 0, find the SUM of the roots.`, answer: r1 + r2 };
                    } else {
                        // ask product
                        return { question: `Given x^2 ${b >= 0 ? '+' + b : b}x ${c >= 0 ? '+' + c : c} = 0, find the PRODUCT of the roots.`, answer: r1 * r2 };
                    }
                } else {
                    // rational equation: (a x) / b = c  -> x = c * b / a
                    const a = Math.floor(Math.random() * 9) + 1;
                    const b = Math.floor(Math.random() * 9) + 1;
                    const x = Math.floor(Math.random() * 11) - 5;
                    const c = (a * x) / b;
                    // make c integer by adjusting x
                    const numerator = a * x;
                    if (Number.isInteger(c)) {
                        return { question: `Solve for x: (${a}x) / ${b} = ${c}`, answer: x };
                    } else {
                        // fallback to simple linear
                        const A = Math.floor(Math.random() * 9) + 1;
                        const B = Math.floor(Math.random() * 21) - 10;
                        const X = Math.floor(Math.random() * 11) - 5;
                        const C = A * X + B;
                        return { question: `Solve for x: ${A}x + ${B} = ${C}`, answer: X };
                    }
                }
            }

            function showChallengeOverlay(problem, onSolved) {
                // create overlay DOM
                const overlay = document.createElement('div');
                overlay.id = 'math-challenge-overlay';
                overlay.style.position = 'fixed';
                overlay.style.left = '0';
                overlay.style.top = '0';
                overlay.style.width = '100%';
                overlay.style.height = '100%';
                overlay.style.display = 'flex';
                overlay.style.alignItems = 'center';
                overlay.style.justifyContent = 'center';
                overlay.style.background = 'rgba(0,0,0,0.6)';
                overlay.style.zIndex = '2000';

                const box = document.createElement('div');
                box.style.background = '#111';
                box.style.color = 'white';
                box.style.padding = '18px';
                box.style.borderRadius = '8px';
                box.style.boxShadow = '0 4px 12px rgba(0,0,0,0.6)';
                box.style.maxWidth = '640px';
                box.style.width = '90%';
                box.style.fontFamily = 'sans-serif';
                box.style.textAlign = 'center';

                const title = document.createElement('div');
                title.style.fontSize = '20px';
                title.style.marginBottom = '8px';
                title.textContent = 'Precalc Challenge — restore stamina by solving';

                const q = document.createElement('div');
                q.style.margin = '12px 0';
                q.style.fontSize = '18px';
                q.textContent = problem.question;

                const input = document.createElement('input');
                input.type = 'text';
                input.placeholder = 'Enter numeric answer (e.g. 3, 2.5)';
                input.style.width = '60%';
                input.style.padding = '8px';
                input.style.borderRadius = '4px';
                input.style.border = '1px solid #444';
                input.style.marginRight = '8px';
                input.style.background = '#222';
                input.style.color = 'white';

                const submit = document.createElement('button');
                submit.textContent = 'Submit';
                submit.style.padding = '8px 12px';
                submit.style.borderRadius = '6px';
                submit.style.border = 'none';
                submit.style.cursor = 'pointer';
                submit.style.background = '#2bc4ff';
                submit.style.color = '#000';
                submit.addEventListener('click', trySubmit);

                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') trySubmit();
                });

                const status = document.createElement('div');
                status.style.marginTop = '12px';
                status.style.minHeight = '18px';
                status.style.color = '#ffd';

                const hint = document.createElement('div');
                hint.style.marginTop = '8px';
                hint.style.fontSize = '12px';
                hint.style.color = '#aaa';
                hint.textContent = 'Answers may be integers or decimals. For multiple roots questions you may be asked for sum or product.';

                const giveUp = document.createElement('button');
                giveUp.textContent = 'Give Up (restore small stamina)';
                giveUp.style.marginLeft = '8px';
                giveUp.style.padding = '6px 8px';
                giveUp.style.borderRadius = '6px';
                giveUp.style.border = 'none';
                giveUp.style.cursor = 'pointer';
                giveUp.style.background = '#666';
                giveUp.style.color = '#fff';
                giveUp.addEventListener('click', () => {
                    cleanup();
                    // partial restore so player can continue
                    onSolved(false);
                });

                box.appendChild(title);
                box.appendChild(q);
                const row = document.createElement('div');
                row.style.display = 'flex';
                row.style.justifyContent = 'center';
                row.style.alignItems = 'center';
                row.appendChild(input);
                row.appendChild(submit);
                row.appendChild(giveUp);
                box.appendChild(row);
                box.appendChild(status);
                box.appendChild(hint);

                overlay.appendChild(box);
                document.body.appendChild(overlay);

                input.focus();

                function trySubmit() {
                    const raw = input.value.trim();
                    if (raw.length === 0) {
                        status.textContent = 'Please enter an answer.';
                        return;
                    }
                    // parse numbers and simple fractions
                    let val = NaN;
                    if (raw.includes('/')) {
                        const parts = raw.split('/');
                        if (parts.length === 2) {
                            const n = parseFloat(parts[0]);
                            const d = parseFloat(parts[1]);
                            if (!isNaN(n) && !isNaN(d) && d !== 0) val = n / d;
                        }
                    } else {
                        val = parseFloat(raw);
                    }
                    if (isNaN(val)) {
                        status.textContent = 'Could not parse that as a number.';
                        return;
                    }
                    const expected = problem.answer;
                    const ok = Math.abs(val - expected) < 1e-6;
                    if (ok) {
                        status.style.color = '#8f8';
                        status.textContent = 'Correct! Restoring stamina...';
                        setTimeout(() => {
                            cleanup();
                            onSolved(true);
                        }, 600);
                    } else {
                        status.style.color = '#f88';
                        status.textContent = 'Incorrect — try again.';
                    }
                }

                function cleanup() {
                    if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
                    challengeActive = false;
                    challengeCallback = null;
                }
            }

            function requireMathChallenge(onComplete) {
                if (challengeActive) return;
                challengeActive = true;
                const problem = generatePrecalcProblem();
                showChallengeOverlay(problem, (solved) => {
                    // solved = true when correct, false when gave up
                    challengeActive = false;
                    if (onComplete) onComplete(solved);
                });
            }

            // ---------- End challenge logic ----------

            // Entity class
            class Fighter {
                constructor(x, y, color = 'cyan') {
                    this.x = x;
                    this.y = y;
                    this.w = 48;
                    this.h = 64;
                    this.vx = 0;
                    this.vy = 0;
                    this.facing = 1; // 1 => right, -1 => left
                    this.color = color;

                    this.maxHealth = 100;
                    this.health = this.maxHealth;

                    // stamina
                    this.maxStamina = 100;
                    this.stamina = this.maxStamina;
                    this.staminaRegenRate = 18; // per second

                    // state: idle, walk, punch, swing, hit, down
                    this.state = 'idle';
                    this.animFrame = 0;
                    this.frameTimer = 0;

                    // jumping/gravity
                    this.isGrounded = false;
                    this.jumpPower = 400; // pixels/second
                    this.jumpsRemaining = 2; // double jump
                    this.doubleJumpDelay = 450; // delay for second jump in ms

                    // attack parameters
                    this.attackData = {
                        punch: {
                            frames: punchFrames,
                            frameDuration: 80, // ms per frame
                            damage: 8,
                            reach: 48,
                            hitOnFrame: 1, // index where damage applies (0-based)
                            knockback: 80,
                            cost: 12
                        },
                        swing: {
                            frames: swingFrames,
                            frameDuration: 110,
                            damage: 18,
                            reach: 84,
                            hitOnFrame: 2,
                            knockback: 140,
                            cost: 28
                        }
                    };

                    this.attackCooldown = 0; // ms
                    this.attackHitApplied = false; // to avoid double-hit in single attack
                }

                getBounds() {
                    return { x: this.x, y: this.y, w: this.w, h: this.h };
                }

                startAttack(type) {
                    if (this.attackCooldown > 0) return false;
                    const d = this.attackData[type];
                    if (!d) return false;
                    if (this.stamina < (d.cost || 0)) return false; // require stamina
                    // deduct stamina
                    this.stamina = Math.max(0, this.stamina - (d.cost || 0));
                    this.state = type;
                    this.animFrame = 0;
                    this.frameTimer = 0;
                    this.attackHitApplied = false;
                    // set cooldown slightly longer than animation
                    this.attackCooldown = d.frameDuration * d.frames.length + 150; // Adjusted cooldown duration
                    return true;
                }

                receiveHit(damage, knockback, sourceX) {
                    this.health = Math.max(0, this.health - damage);
                    // simple knockback away from attacker
                    this.vx = (this.x < sourceX ? -1 : 1) * Math.abs(knockback);
                    this.state = 'hit';
                }

                jump() {
                    if (this.jumpsRemaining > 0) {
                        // if using second jump, enforce delay
                        if (this.jumpsRemaining === 1 && this.doubleJumpDelay > 0) {
                            return;
                        }
                        // require a bit of stamina to jump
                        const jumpCost = 14;
                        if (this.stamina < jumpCost) return;
                        this.stamina = Math.max(0, this.stamina - jumpCost);

                        this.vy = -this.jumpPower;
                        this.jumpsRemaining--;
                        if (this.jumpsRemaining === 1) {
                            this.doubleJumpDelay = 200; // 200ms delay before second jump is available
                        }
                    }
                }

                update(dt) {
                    // dt in ms
                    // movement friction
                    this.vx *= 0.92;

                    // double jump delay countdown
                    if (this.doubleJumpDelay > 0) {
                        this.doubleJumpDelay = Math.max(0, this.doubleJumpDelay - dt);
                    }

                    // gravity
                    const gravity = 1200; // pixels/second^2
                    this.vy += gravity * dt / 1000;
                    this.x += this.vx * dt / 1000;
                    this.y += this.vy * dt / 1000;

                    // collision with platforms
                    this.isGrounded = false;
                    for (let platform of platforms) {
                        // check if falling onto platform
                        if (this.vy >= 0 &&
                            this.y + this.h >= platform.y &&
                            this.y + this.h <= platform.y + platform.h + 10 &&
                            this.x + this.w > platform.x &&
                            this.x < platform.x + platform.w) {
                            this.y = platform.y - this.h;
                            this.vy = 0;
                            this.isGrounded = true;
                            this.jumpsRemaining = 2; // reset jumps when grounded
                            this.doubleJumpDelay = 0; // reset double jump delay
                        }
                    }

                    // clamp inside canvas horizontally
                    this.x = Math.max(10, Math.min(canvas.width - this.w - 10, this.x));

                    // fall off bottom
                    if (this.y > canvas.height) {
                        this.health = 0;
                    }

                    // attack cooldown
                    if (this.attackCooldown > 0) this.attackCooldown = Math.max(0, this.attackCooldown - dt);

                    // stamina regen (only when not completely exhausted? regen always)
                    if (this.stamina < this.maxStamina) {
                        this.stamina = Math.min(this.maxStamina, this.stamina + this.staminaRegenRate * dt / 1000);
                    }

                    // handle animations if attacking
                    if (this.state === 'punch' || this.state === 'swing') {
                        const data = this.attackData[this.state];
                        this.frameTimer += dt;
                        while (this.frameTimer >= data.frameDuration) {
                            this.frameTimer -= data.frameDuration;
                            this.animFrame++;
                            if (this.animFrame >= data.frames.length) {
                                this.state = 'idle';
                                this.animFrame = 0;
                            }
                        }
                    } else if (this.state === 'hit') {
                        // recover after short time
                        this.frameTimer += dt;
                        if (this.frameTimer > 300) {
                            this.frameTimer = 0;
                            this.state = 'idle';
                        }
                    } else {
                        // idle/walk
                        if (Math.abs(this.vx) > 10) this.state = 'walk';
                        else this.state = 'idle';
                    }
                }

                currentAttackHitbox() {
                    if (this.state !== 'punch' && this.state !== 'swing') return null;
                    const data = this.attackData[this.state];
                    const reach = data.reach;
                    // place hitbox in front of fighter
                    const hb = {
                        x: this.x + (this.facing === 1 ? this.w : -reach),
                        y: this.y + 10,
                        w: reach,
                        h: this.h - 20
                    };
                    return hb;
                }

                draw(ctx) {
                    ctx.save();
                    // flip around fighter center if facing left
                    ctx.translate(this.x + this.w / 2, this.y + this.h / 2);
                    ctx.scale(this.facing, 1);
                    ctx.translate(- (this.x + this.w / 2), - (this.y + this.h / 2));

                    // select sprite:
                    // - when attacking use the relevant attack frame
                    // - otherwise use base sprite (player0_0.png) as the idle sprite if available
                    let img = null;
                    if (this.state === 'punch') {
                        const frames = this.attackData.punch.frames;
                        img = frames[Math.min(this.animFrame, frames.length - 1)];
                    } else if (this.state === 'swing') {
                        // Use baseSprite for swing animations
                        img = baseSprite;
                    } else {
                        img = baseSprite || punchFrames[0];
                    }

                    let drewImage = false;
                    if (img && img.complete && img.naturalWidth > 0) {
                        ctx.drawImage(img, this.x, this.y, this.w, this.h);
                        drewImage = true;
                    }

                    if (!drewImage) {
                        // fallback placeholder
                        ctx.fillStyle = this.color;
                        ctx.fillRect(this.x, this.y, this.w, this.h);
                        ctx.fillStyle = 'black';
                        ctx.fillRect(this.x + 8, this.y + 10, 8, 8);
                        ctx.fillRect(this.x + 32, this.y + 10, 8, 8);
                        ctx.strokeStyle = 'black';
                        ctx.beginPath();
                        ctx.moveTo(this.x + 14, this.y + 40);
                        ctx.lineTo(this.x + 34, this.y + 40);
                        ctx.stroke();
                        ctx.fillStyle = 'white';
                        ctx.font = '10px sans-serif';
                        ctx.fillText(this.state, this.x, this.y - 6);
                    }

                    // If swinging, overlay a sword image that rotates based on the current animation frame.
                    if (this.state === 'swing' && swordImg && swordImg.complete && swordImg.naturalWidth > 0) {
                        // define a set of angles for each frame to approximate a swinging arc
                        const angles = [-1.2, -0.6, -0.1, 0.6, 1.2]; // radians
                        const data = this.attackData.swing;
                        const frameIndex = Math.min(this.animFrame, angles.length - 1);
                        // small interpolation using frameTimer to smooth between frames
                        const nextIndex = Math.min(frameIndex + 1, angles.length - 1);
                        const t = data.frameDuration > 0 ? (this.frameTimer / data.frameDuration) : 0;
                        const angle = angles[frameIndex] * (1 - t) + angles[nextIndex] * t;

                        // pivot point for the sword (approximate hand position, relative to fighter)
                        const pivotX = this.x + this.w - 8; // near right hand in sprite coords
                        const pivotY = this.y + 22;

                        // sword draw size - maintain proper aspect ratio
                        // compute desired sword height relative to the fighter, then compute width from image aspect ratio
                        const desiredSwordHeight = Math.max(12, this.h * 0.35);
                        const imgAR = swordImg.naturalWidth / swordImg.naturalHeight;
                        const swordH = desiredSwordHeight;
                        const swordW = swordH * imgAR;

                        // draw rotated sword around pivot
                        ctx.save();
                        ctx.translate(pivotX, pivotY);
                        ctx.rotate(angle);
                        // position the sword so the handle sits near the pivot; use a proportional offset based on computed width
                        const handleOffset = swordW * 0.2;
                        ctx.drawImage(swordImg, -handleOffset, -swordH / 2, swordW, swordH);
                        ctx.restore();
                    }

                    ctx.restore();

                    // health bar
                    const barW = 80;
                    const bx = this.x + this.w / 2 - barW / 2;
                    const by = this.y - 14;
                    ctx.fillStyle = 'black';
                    ctx.fillRect(bx - 1, by - 1, barW + 2, 8 + 2);
                    ctx.fillStyle = 'red';
                    ctx.fillRect(bx, by, barW, 8);
                    ctx.fillStyle = 'lime';
                    ctx.fillRect(bx, by, Math.floor(barW * (this.health / this.maxHealth)), 8);

                    // stamina bar (below health)
                    const sby = by + 12;
                    ctx.fillStyle = 'black';
                    ctx.fillRect(bx - 1, sby - 1, barW + 2, 6 + 2);
                    ctx.fillStyle = '#123'; // background tone
                    ctx.fillRect(bx, sby, barW, 6);
                    // stamina color: cyan-ish
                    const staminaW = Math.floor(barW * (this.stamina / this.maxStamina));
                    ctx.fillStyle = '#2bc4ff';
                    ctx.fillRect(bx, sby, staminaW, 6);

                    // small stamina percent text
                    ctx.fillStyle = 'white';
                    ctx.font = '9px sans-serif';
                    ctx.fillText(Math.floor(this.stamina) + ' / ' + this.maxStamina, bx + barW + 6, sby + 5);
                }
            }

            // Game objects
            const player = new Fighter(80, canvas.height - 200, '#2bc4ff');
            const enemy = new Fighter(canvas.width - 140, canvas.height - 200, '#ff6b6b');
            enemy.facing = -1;

            // Player input and controls
            function handlePlayerInput(dt) {
                const speed = 220;
                if (KEYS['a'] || KEYS['arrowleft']) {
                    player.vx = -speed;
                    player.facing = -1;
                } else if (KEYS['d'] || KEYS['arrowright']) {
                    player.vx = speed;
                    player.facing = 1;
                } else {
                    player.vx *= 0.7;
                }

                // jump: w or space
                if ((KEYS['w'] || KEYS[' ']) && player.jumpsRemaining > 0) {
                    if (player.stamina < 10) {
                        // require math challenge before allowing stamina-consuming actions (jumps cost stamina)
                        if (!challengeActive) {
                            requireMathChallenge((solved) => {
                                // if solved, grant modest stamina and then attempt the jump
                                if (solved) {
                                    player.stamina = Math.min(player.maxStamina, player.stamina + 30);
                                } else {
                                    // gave up: grant a small chunk so player can continue
                                    player.stamina = Math.min(player.maxStamina, player.stamina + 8);
                                }
                                // try the jump again immediately if still requested
                                if ((KEYS['w'] || KEYS[' ']) && player.jumpsRemaining > 0) {
                                    player.jump();
                                }
                            });
                        }
                    } else {
                        // allowed normally
                        player.jump();
                    }
                }

                // attacks: z = punch, x = swing
                if ((KEYS['z'] || KEYS['x']) && player.state !== 'punch' && player.state !== 'swing') {
                    // If stamina very low, require challenge before stamina-consuming attack
                    if (player.stamina < 10) {
                        if (!challengeActive) {
                            requireMathChallenge((solved) => {
                                if (solved) {
                                    player.stamina = Math.min(player.maxStamina, player.stamina + 30);
                                } else {
                                    player.stamina = Math.min(player.maxStamina, player.stamina + 8);
                                }
                                // if still pressing attack, try to start it
                                if ((KEYS['z'] || KEYS['x']) && player.state !== 'punch' && player.state !== 'swing') {
                                    if (KEYS['z']) player.startAttack('punch');
                                    else if (KEYS['x']) player.startAttack('swing');
                                }
                            });
                        }
                    } else {
                        if (KEYS['z']) player.startAttack('punch');
                        else if (KEYS['x']) player.startAttack('swing');
                    }
                }
            }

            // Simple AI for enemy
            let enemyThinkTimer = 0;
            function enemyBehavior(dt) {
                enemyThinkTimer -= dt;
                if (enemyThinkTimer <= 0) {
                    enemyThinkTimer = 300 + Math.random() * 700;
                    // decide action
                    const dx = player.x - enemy.x;
                    if (Math.abs(dx) > 160) {
                        // move toward player
                        enemy.vx = dx > 0 ? 120 : -120;
                        enemy.facing = dx > 0 ? 1 : -1;
                    } else {
                        // stop and maybe attack
                        enemy.vx = 0;
                        enemy.facing = dx > 0 ? 1 : -1;
                        // choose attack if cooldown available and has stamina
                        if (Math.random() < 0.6) {
                            const choice = Math.random() < 0.6 ? 'punch' : 'swing';
                            // only start if enough stamina
                            if (enemy.stamina >= (enemy.attackData[choice].cost || 0)) {
                                enemy.startAttack(choice);
                            }
                        }
                    }
                }
                
                // randomly jump
                if (Math.random() < 0.02 && enemy.jumpsRemaining > 0 && enemy.stamina > 16) {
                    enemy.jump();
                }
            }

            // Hit resolution: called each frame to check if attack hit should apply damage
            function resolveAttacks(attacker, defender) {
                if ((attacker.state !== 'punch' && attacker.state !== 'swing') || attacker.attackHitApplied) return;
                const data = attacker.attackData[attacker.state];
                if (attacker.animFrame !== data.hitOnFrame) return;
                // compute hitbox and check intersection
                const hb = attacker.currentAttackHitbox();
                if (!hb) return;
                if (rectIntersect(hb, defender.getBounds())) {
                    attacker.attackHitApplied = true;
                    defender.receiveHit(data.damage, data.knockback, attacker.x);
                }
            }

            // Game loop
            let last = performance.now();
            function step(now) {
                const dt = Math.min(40, now - last); // cap dt
                last = now;

                // If the challenge overlay is active, do not perform game-updating logic that would consume stamina or change state.
                if (!challengeActive) {
                    // update
                    handlePlayerInput(dt);
                    enemyBehavior(dt);

                    player.update(dt);
                    enemy.update(dt);

                    // facing corrections
                    if (player.x < enemy.x) {
                        player.facing = 1;
                        enemy.facing = -1;
                    } else {
                        player.facing = -1;
                        enemy.facing = 1;
                    }

                    // resolve attacks (both directions)
                    resolveAttacks(player, enemy);
                    resolveAttacks(enemy, player);
                } else {
                    // When paused for challenge, still allow player to slightly move if keys held (visual only).
                    // Small damped movement so player doesn't feel totally frozen.
                    if (KEYS['a'] || KEYS['arrowleft']) player.vx = Math.max(player.vx - 10 * dt / 16, -120);
                    if (KEYS['d'] || KEYS['arrowright']) player.vx = Math.min(player.vx + 10 * dt / 16, 120);
                    player.x += player.vx * dt / 1000;
                    // keep within bounds
                    player.x = Math.max(10, Math.min(canvas.width - player.w - 10, player.x));
                }

                // render
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                // background
                ctx.fillStyle = '#111';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // draw platforms
                ctx.fillStyle = '#444';
                for (let platform of platforms) {
                    ctx.fillRect(platform.x, platform.y, platform.w, platform.h);
                }

                // floor line
                ctx.strokeStyle = '#333';
                ctx.beginPath();
                ctx.moveTo(0, canvas.height - 10);
                ctx.lineTo(canvas.width, canvas.height - 10);
                ctx.stroke();

                player.draw(ctx);
                enemy.draw(ctx);

                // UI text
                ctx.fillStyle = 'white';
                ctx.font = '14px sans-serif';
                ctx.fillText('Controls: A/D or ←/→ to move, W or Space to jump (double jump), Z = Punch, X = Swing', 10, 20);

                // hint for challenge
                if (player.stamina < 10 && !challengeActive) {
                    ctx.fillStyle = '#ffd';
                    ctx.font = '13px sans-serif';
                    ctx.fillText('Stamina low. Attacks and jumps require solving a precalc problem. Press Z/X or W to trigger the challenge.', 10, 40);
                }

                // end of round: check deaths
                if (player.health <= 0 || enemy.health <= 0) {
                    ctx.fillStyle = 'rgba(0,0,0,0.6)';
                    ctx.fillRect(0, canvas.height/2 - 60, canvas.width, 120);
                    ctx.fillStyle = 'white';
                    ctx.font = '32px sans-serif';
                    const msg = player.health <= 0 ? 'You Lose' : 'You Win';
                    ctx.fillText(msg, canvas.width/2 - 60, canvas.height/2);
                    // stop game loop (do not request another frame)
                    return;
                }

                requestAnimationFrame(step);
            }
            requestAnimationFrame(step);
        </script>

    </body>
</html>