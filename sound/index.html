<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Sound Wave Simulation</title>
    <link rel="icon" href="../images/favicon.png" type="image/png">
    <style>
        :root {
            --bg: #222;
            --panel: #333;
            --muted: #999;
        }

        body {
            font-family: Arial, Helvetica, sans-serif;
            margin: 20px;
            padding-top: 64px;
            background: var(--bg);
            color: #fff;
        }

        .header {
            background: var(--panel);
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, .2);
            z-index: 1000;
        }

        .goback {
            background-color: #222222;
            top: 0;
            color: white;
            left: 0;
            padding: 10px;
            font-size: 24px;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            border: none;
            border-radius: 10px;
            cursor: pointer;
        }

        h1 {
            margin-top: 0;
        }

        #controls {
            margin-top: 12px;
            background: var(--panel);
            padding: 12px;
            border-radius: 10px;
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
        }

        label {
            display: inline-flex;
            gap: 8px;
            align-items: center;
        }

        input[type=text] {
            min-width: 220px;
            padding: 6px;
            border-radius: 4px;
            border: 0;
            background: #111;
            color: #fff;
        }

        button {
            padding: 8px 12px;
            border-radius: 6px;
            border: 0;
            cursor: pointer;
        }

        #simulationCanvas {
            background: #111;
            display: block;
            width: 100%;
            height: 62vh;
            margin-top: 12px;
        }

        .micPanel {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            margin-top: 12px;
        }

        .micCard {
            background: #1b1b1b;
            padding: 8px;
            border-radius: 8px;
            width: 220px;
        }

        canvas.small {
            width: 100%;
            height: 60px;
            background: #000;
            display: block;
        }

        .legend {
            margin-left: 8px;
            color: var(--muted);
            font-size: 13px;
        }
    </style>
</head>

<body>
    <div class="header"><button class="goback" onclick="location.href='../'">Physics Simulations</button></div>
    <h1>Sound Wave Simulation</h1>
    <p>Ripple tank with vibrating sources, obstacles, and microphones producing real-time audio.</p>
    <div id="controls">
        <label>Frequency <input id="freq" type="range" min="0.1" max="5" step="0.1" value="2"></label>
        <label>Damping <input id="damp" type="range" min="0.95" max="0.999" step="0.001" value="0.996"></label>
        <label>Speaker Function <input id="speakerFunc" type="text" value="Math.sin(2*Math.PI*freq*t)"></label>
        <button id="applyFunc">Apply</button>
        <button id="addSource">Add Source</button>
        <button id="addMic">Add Microphone</button>
        <button id="addObstacle">Add Obstacle</button>
        <button id="pulse">Pulse</button>
        <button id="startAudio">Start Audio</button>
        <label class="legend">Click canvas after pressing Add Source / Add Microphone / Add Obstacle to place.</label>
    </div>
    <canvas id="simulationCanvas"></canvas>
    <div class="micPanel" id="micPanel"></div>
    <script>
        // --- canvas/grid setup ---
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        function resizeCanvas() { canvas.width = window.innerWidth - 40; canvas.height = window.innerHeight * 0.62; }
        window.addEventListener('resize', () => { resizeCanvas(); recalcGrid(); });
        resizeCanvas();
        let scale = 3, cols = Math.floor(canvas.width / scale), rows = Math.floor(canvas.height / scale);
        let grid = [], prev = [];
        function makeGrid() { cols = Math.max(20, Math.floor(canvas.width / scale)); rows = Math.max(20, Math.floor(canvas.height / scale)); grid = Array.from({ length: rows }, () => new Float32Array(cols)); prev = Array.from({ length: rows }, () => new Float32Array(cols)); }
        makeGrid();
        function recalcGrid() { makeGrid(); }
        const obstacles = new Set();
        const sources = []; // {x,y,r,freq,phase,fn}
        const microphones = [];
        let pendingAction = null;

        canvas.addEventListener('click', e => {
            const r = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - r.left) / scale);
            const y = Math.floor((e.clientY - r.top) / scale);
            if (pendingAction === 'source') { const freq = parseFloat(defaultFreqInput.value) || 440; sources.push({ x, y, r: 5, freq, phase: 0, fn: currentSpeakerFn }); }
            else if (pendingAction === 'mic') { addMicrophone(x, y); }
            else if (pendingAction === 'obstacle') { obstacles.add(y * cols + x); }
            pendingAction = null;
        });

        document.getElementById('addSource').onclick = () => pendingAction = 'source';
        document.getElementById('addMic').onclick = () => pendingAction = 'mic';
        document.getElementById('addObstacle').onclick = () => pendingAction = 'obstacle';
        document.getElementById('pulse').onclick = () => { const cx = Math.floor(cols / 2), cy = Math.floor(rows / 2); for (let yy = cy - 2; yy <= cy + 2; yy++) for (let xx = cx - 2; xx <= cx + 2; xx++) if (xx >= 0 && yy >= 0 && xx < cols && yy < rows) grid[yy][xx] = 1; };

        // --- audio setup ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let audioStarted = false;
        const masterGain = audioCtx.createGain(); masterGain.gain.value = 0.6; masterGain.connect(audioCtx.destination);

        // speaker function parser
        let speakerFuncInput = document.getElementById('speakerFunc');
        let currentSpeakerFn = t => Math.sin(2 * Math.PI * t);
        function compileSpeakerFn(str) { try { return new Function('t', 'x', 'y', 'freq', 'return (' + str + ')'); } catch (e) { console.error(e); return t => Math.sin(2 * Math.PI * t); } }
        currentSpeakerFn = compileSpeakerFn(speakerFuncInput.value);
        document.getElementById('applyFunc').onclick = () => { currentSpeakerFn = compileSpeakerFn(speakerFuncInput.value); sources.forEach(s => s.fn = currentSpeakerFn); };
        document.getElementById('startAudio').onclick = async () => { if (audioCtx.state !== 'running') await audioCtx.resume(); audioStarted = true; };

        function addMicrophone(x, y) {
            const carrier = audioCtx.createOscillator(); carrier.type = 'sine'; carrier.frequency.value = 440;
            const filter = audioCtx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 2000;
            const envGain = audioCtx.createGain(); envGain.gain.value = 0;
            const panner = audioCtx.createStereoPanner();
            carrier.connect(filter); filter.connect(envGain); envGain.connect(panner); panner.connect(masterGain);
            const analyser = audioCtx.createAnalyser(); analyser.fftSize = 1024; panner.connect(analyser);
            carrier.start();
            const mic = { x, y, history: [], carrier, filter, envGain, panner, analyser, envLevel: 0, cutoff: 2000 }; microphones.push(mic); createMicCard(mic);
        }

        function createMicCard(mic) {
            const panel = document.getElementById('micPanel');
            const card = document.createElement('div'); card.className = 'micCard';
            const title = document.createElement('div'); title.textContent = `Mic @ (${mic.x},${mic.y})`;
            const canvasWave = document.createElement('canvas'); canvasWave.className = 'small'; canvasWave.width = 200; canvasWave.height = 60;
            const canvasFFT = document.createElement('canvas'); canvasFFT.className = 'small'; canvasFFT.width = 200; canvasFFT.height = 60;
            const cutoffLabel = document.createElement('label'); cutoffLabel.textContent = 'Cutoff:';
            const cutoffInput = document.createElement('input'); cutoffInput.type = 'range'; cutoffInput.min = 200; cutoffInput.max = 8000; cutoffInput.value = 2000; cutoffInput.oninput = () => { mic.filter.frequency.value = cutoffInput.value; mic.cutoff = cutoffInput.value; };
            card.appendChild(title); card.appendChild(canvasWave); card.appendChild(canvasFFT); card.appendChild(cutoffLabel); card.appendChild(cutoffInput);
            panel.appendChild(card);
            mic._waveCanvas = canvasWave; mic._fftCanvas = canvasFFT; mic._card = card;
        }
        document.body.onclick = () => { if (audioCtx.state === 'suspended') audioCtx.resume(); };

        // --- simulation ---
        const defaultFreqInput = document.createElement('input'); defaultFreqInput.type = 'number'; defaultFreqInput.min = 20; defaultFreqInput.max = 2000; defaultFreqInput.value = 440; defaultFreqInput.style.width = '80px';
        const freqLabel = document.createElement('label'); freqLabel.textContent = 'Default Source Freq:'; freqLabel.appendChild(defaultFreqInput);
        const controls = document.getElementById('controls'); controls.insertBefore(freqLabel, controls.children[3]);

        function update() {
            const damp = parseFloat(document.getElementById('damp').value);
            const tNow = performance.now() / 1000;
            for (let y = 1; y < rows - 1; y++) for (let x = 1; x < cols - 1; x++) {
                const idx = y * cols + x;
                if (obstacles.has(idx)) { grid[y][x] = prev[y][x] = 0; continue; }
                const val = (prev[y - 1][x] + prev[y + 1][x] + prev[y][x - 1] + prev[y][x + 1]) / 2 - grid[y][x];
                grid[y][x] = val * damp;
            }

            let overrideFreq = true;

            for (const s of sources) {
                const t = performance.now() / 1000; // time in seconds
                let freq = s.freq;                  // source's frequency
                if (overrideFreq) freq = parseFloat(document.getElementById('freq').value);
                let v = 0;
                try {
                    v = s.fn(t, s.x, s.y, freq);
                } catch (e) {
                    v = Math.sin(2 * Math.PI * freq * t);
                }
                // emit as a circular patch, radius r
                const r = s.r || 1;
                for (let yy = -r; yy <= r; yy++) {
                    for (let xx = -r; xx <= r; xx++) {
                        const X = s.x + xx, Y = s.y + yy;
                        if (X < 0 || Y < 0 || X >= cols || Y >= rows) continue;
                        if (xx * xx + yy * yy <= r * r) grid[Y][X] = v;
                    }
                }
            }

            for (const mic of microphones) {
                const v = (prev[mic.y] && prev[mic.y][mic.x]) ? prev[mic.y][mic.x] : 0;
                const envSmooth = 0.08; mic.envLevel += (Math.abs(v) - mic.envLevel) * envSmooth;
                const gainVal = Math.min(1, mic.envLevel * 4);
                mic.envGain.gain.setTargetAtTime(gainVal, audioCtx.currentTime, 0.01);
                const pan = (mic.x / cols) * 2 - 1; mic.panner.pan.setTargetAtTime(pan, audioCtx.currentTime, 0.01);
                mic.carrier.frequency.setTargetAtTime(220 + gainVal * 880, audioCtx.currentTime, 0.01);
                mic.history.push(v); if (mic.history.length > canvas.width / 4) mic.history.shift();
            }
            const tmp = prev; prev = grid; grid = tmp;
        }
        function draw() {
            const img = ctx.createImageData(cols, rows);
            for (let y = 0; y < rows; y++) for (let x = 0; x < cols; x++) {
                const i = (y * cols + x) * 4; const v = prev[y][x];
                const amp = Math.max(-1, Math.min(1, v));
                const r = amp > 0 ? Math.floor(amp * 255) : 0;
                const b = amp < 0 ? Math.floor(-amp * 255) : 0;
                const g = 0;//Math.floor((1 - Math.min(1, Math.abs(amp))) * 255 * 0.6);
                img.data[i] = r; img.data[i + 1] = g; img.data[i + 2] = b; img.data[i + 3] = 255;
            }
            const off = document.createElement('canvas'); off.width = cols; off.height = rows; off.getContext('2d').putImageData(img, 0, 0);
            ctx.imageSmoothingEnabled = false; ctx.drawImage(off, 0, 0, cols, rows, 0, 0, canvas.width, canvas.height);
            for (const o of obstacles) { const ox = o % cols, oy = (o / cols) | 0; ctx.fillStyle = 'gray'; ctx.fillRect(ox * scale, oy * scale, scale, scale); }
            for (const s of sources) { ctx.fillStyle = 'yellow'; ctx.fillRect(s.x * scale, s.y * scale, scale, scale); }
            for (const m of microphones) { ctx.fillStyle = 'lime'; ctx.fillRect(m.x * scale, m.y * scale, scale, scale); }
        }
        function drawMicVisuals() { for (const mic of microphones) { const wc = mic._waveCanvas, wf = mic._fftCanvas; if (!wc || !wf) continue; const wctx = wc.getContext('2d'); wctx.clearRect(0, 0, wc.width, wc.height); wctx.fillStyle = '#000'; wctx.fillRect(0, 0, wc.width, wc.height); wctx.strokeStyle = '#0f0'; wctx.beginPath(); const hist = mic.history; for (let i = 0; i < hist.length; i++) { const x = (i / hist.length) * wc.width; const y = (1 - (hist[i] * 0.5 + 0.5)) * wc.height; if (i === 0) wctx.moveTo(x, y); else wctx.lineTo(x, y); } wctx.stroke(); const af = mic.analyser; const freqData = new Uint8Array(af.frequencyBinCount); af.getByteFrequencyData(freqData); const fctx = wf.getContext('2d'); fctx.clearRect(0, 0, wf.width, wf.height); fctx.fillStyle = '#000'; fctx.fillRect(0, 0, wf.width, wf.height); fctx.fillStyle = '#ff0'; const step = Math.max(1, Math.floor(freqData.length / wf.width)); for (let i = 0; i < wf.width; i++) { const v = freqData[i * step] / 255; const bar = v * wf.height; fctx.fillRect(i, wf.height - bar, 1, bar); } } }
        function animate() { update(); draw(); drawMicVisuals(); requestAnimationFrame(animate); }
        animate();
        window.__sim = { sources, microphones, obstacles, compileSpeakerFn };
    </script>
</body>

</html>